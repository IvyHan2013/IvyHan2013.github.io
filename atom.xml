<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yutong Han&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.yutong-han.net/"/>
  <updated>2018-01-04T07:42:20.783Z</updated>
  <id>http://www.yutong-han.net/</id>
  
  <author>
    <name>Yutong Han</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Dairy-2018-01-03</title>
    <link href="http://www.yutong-han.net/2018/01/03/dairy-0103/"/>
    <id>http://www.yutong-han.net/2018/01/03/dairy-0103/</id>
    <published>2018-01-03T18:32:14.888Z</published>
    <updated>2018-01-04T07:42:20.783Z</updated>
    
    <content type="html"><![CDATA[<p>每日学习日记 2018-01-03<br><a id="more"></a></p><h4 id="44-Wildcard-Matching"><a href="#44-Wildcard-Matching" class="headerlink" title="44. Wildcard Matching"></a><a href="https://leetcode.com/problems/wildcard-matching/description/" target="_blank" rel="noopener">44. Wildcard Matching</a></h4><ul><li>字符串的dp </li><li>二维dp数组 dp[i][j]</li></ul><h4 id="10-Regular-Expression-Matching"><a href="#10-Regular-Expression-Matching" class="headerlink" title="10.Regular Expression Matching"></a><a href="https://leetcode.com/problems/regular-expression-matching/description/" target="_blank" rel="noopener">10.Regular Expression Matching</a></h4><ul><li>也是字符串的dp</li></ul><h4 id="279-Perfect-Squares"><a href="#279-Perfect-Squares" class="headerlink" title="279. Perfect Squares"></a><a href="https://leetcode.com/problems/perfect-squares/description/" target="_blank" rel="noopener">279. Perfect Squares</a></h4><ul><li>Done in Dp</li></ul><h4 id="Coin-Change"><a href="#Coin-Change" class="headerlink" title="Coin Change"></a><a href="https://leetcode.com/problems/coin-change/description/" target="_blank" rel="noopener">Coin Change</a></h4><p>找零钱问题，很经典了<br>dp思路和上面那个一毛一样</p><h4 id="455-Assign-Cookies"><a href="#455-Assign-Cookies" class="headerlink" title="455. Assign Cookies"></a><a href="https://leetcode.com/problems/assign-cookies/description/" target="_blank" rel="noopener">455. Assign Cookies</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public int findContentChildren(int[] g, int[] s) &#123;</span><br><span class="line">       Arrays.sort (g);//g is children array</span><br><span class="line">       Arrays.sort(s);//s is cookie array</span><br><span class="line">       int i =0;</span><br><span class="line">       for(int j=0;i&lt;g.length&amp;&amp;j&lt;s.length;j++)&#123;</span><br><span class="line">           if(g[i]&lt;=s[j])i++;</span><br><span class="line">       &#125;</span><br><span class="line">       return i;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;每日学习日记 2018-01-03&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>操作系统复习笔记 03</title>
    <link href="http://www.yutong-han.net/2018/01/02/OS-3/"/>
    <id>http://www.yutong-han.net/2018/01/02/OS-3/</id>
    <published>2018-01-03T05:49:09.681Z</published>
    <updated>2018-01-05T08:22:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>进程 进程状态 PCB 进程调度 进程创建和删除 进程间通信<br><a id="more"></a></p><h3 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h3><ul><li>A process is a program in execution.</li><li>A process is more than the program code, sometimes knowns as the <strong>text section</strong></li><li>It also includes the current activity, represented by the value of the <strong>program counter</strong> and the contenxts of the processor’s registers</li><li>A process also includes <strong>stacks</strong> contains temporary data(function parameters, return address and local variables)</li><li>and a <strong>data section</strong> contains global variables.</li><li>A process may also include a <strong>heap</strong>, which is memory that is dynamically allocated during process runtime.</li></ul><p><img src="/images/PIM.jpg" alt="Process in Memory"></p><h3 id="Process-State"><a href="#Process-State" class="headerlink" title="Process State"></a>Process State</h3><p>![Diagram of process state(/images/DPS.png)</p><h4 id="Process-Control-Block-进程控制块"><a href="#Process-Control-Block-进程控制块" class="headerlink" title="Process Control Block(进程控制块)"></a>Process Control Block(进程控制块)</h4><ul><li>Each process is represented in the operating syetem by a <strong>process control block(PCB)</strong> <ul><li><strong>Process state</strong>: <strong>new</strong>, <strong>ready</strong>, <strong>running</strong>, <strong>waiting</strong>, <strong>halted</strong> and so on.</li><li><strong>Program counter</strong>: The counter indicates the address of the next instruction to be execyted for this process</li><li><strong>CPU registers</strong>: Include <strong>accumulators</strong>, <strong>index registers</strong>, <strong>stack pointers</strong>, and <strong>general-purpose registers</strong> plus any <strong>condition-code information</strong>. These infomation must be saves when an interrput occurs,to allow the process to be continued correctly afterward.</li><li><strong>CPU-scheduling information</strong>: Include <strong>process priority</strong>, <strong>pointers to scheduling queues</strong></li><li><strong>Memory-management informatiom</strong>: Include such items as the value of the base and <strong>limit registers</strong> and the <strong>page tables</strong> or the <strong>segment tables </strong></li><li><strong>Accounting information</strong>: <strong>CPU and real time used</strong>, <strong>time limit</strong>, <strong>account numbers</strong>, <strong>job or process numbers</strong></li><li><strong>I/O status information</strong> </li></ul></li></ul><p>###Threads</p><ul><li>PCB is extended to include information for each thread.</li></ul><h3 id="Process-respresentation-in-Linux"><a href="#Process-respresentation-in-Linux" class="headerlink" title="Process respresentation in Linux"></a>Process respresentation in Linux</h3><p>通过一个task_structure的双向链表来保存</p><h3 id="进程调度-Process-Scheduling"><a href="#进程调度-Process-Scheduling" class="headerlink" title="进程调度 Process Scheduling"></a>进程调度 Process Scheduling</h3><p>多到程序设计的目的是 无论合适都有进程在运行， 从而使CPU利用率达到最大化。<br>为了达到此目的，进程调度选择一个可用的进程到CPU上执行。</p><h4 id="调度队列-Scheduling-Queue"><a href="#调度队列-Scheduling-Queue" class="headerlink" title="调度队列 Scheduling Queue"></a>调度队列 Scheduling Queue</h4><p>进程进入系统的时候，会被加入到<strong>作业队列</strong>中，该队列包括系统中的所有进程。</p><p>驻留在内存中就绪的的进程保存在<strong>就绪队列</strong>中。</p><p>该队列通常用链表来实现，其头节点指向链表的第一个和最后一个PCB块的指针。</p><p>每个PCB包括一个指向就绪队列的下一个PCB的指针域。</p><p>操作系统中也有其他队列。当给进程分配了PCPU后，它开始执行冰最终完成，或被中断，或等待特定事件发生（如完成I/O请求）。 假设进程向一个共享设备发送IO请求，由于系统有许多进程，磁盘可能会忙于其他进程的IO请求，因此改进程可能需要等待磁盘。等待特定IO设备的进程列表被称为<strong>设备队列</strong>。 </p><p>新进程开始处于就绪队列。它在就绪队列中等待直到被选中执行或被派遣。当进程分配到CPU并执行是，可能发生下面集中事情中的一种：</p><ul><li>进程可能发出一个I/O请求，被被放到I/O队列中。</li><li>进程可能创建一个新的子进程，被等待其结束</li><li>进程可能会忧郁中断而强制释放CPU，被被放回到就绪队列中。</li></ul><p>对于前两种情况，进程最终从等待状态切换到就绪态，并放回到就绪队列中，进程继续这一循环直到终止，到时它将从所有队列中删除，其PCB和资源将得以释放。</p><h4 id="调度程序-Scheduler"><a href="#调度程序-Scheduler" class="headerlink" title="调度程序 Scheduler"></a>调度程序 Scheduler</h4><p>通常对于批处理系统，进程更多的是被提交而不是马上被执行。这些进程被放到大荣了存储设备（通常为磁盘）的缓冲池中，保存在那里以便以后执行。</p><p>长期调度程序（long-term scheduler）或 作业调度程序（job scheduler）从该池中选择进程，被装入内存以准备执行。</p><p>短期调度程序（short-term scheduler）或 CPU调度程序 从准备执行的进程中选择进程，并为之分配CPU。</p><p>这两个调度程序的主要差别是它们执行的频率。短期调度程序必须频繁地为CPU选择新进程。</p><p>长期调度程序执行得并不频繁，在进程被新进程的创建之间可能有数分钟间隔。长期调度程序控制多到程序设计的程度。如果多道程序的程度稳定，纳闷创建进程的平均速度必须等于进程离开系统的平均速度。由于每次执行之间时间间隔较长，长期调度程序能使用更多时间来选择执行程序。</p><p>通常，绝大数进程可以分为：<strong>I/O为主</strong>或<strong>CPU为主</strong>。I/O为主的进程在执行I/O方面比执行计算花费更多时间，CPU为主的进程很少产生I/O请求，与I/O为主的进程相比将更多的时间用在执行计算上。</p><p>因此，长期调度程序应该选择一个合理的包含IO为主和CPU为主的组合进程。</p><p>有些系统如分时系统可能引入另外的中期调度程序。中期调度程序的核心思想是能将进程从内存中移出，从而降低多到程序设计的程度。之后进程能被重新调入内存，并从中断出仅需执行。这种方案称为交换（swapping）。</p><h4 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h4><p>中断使CPU从当前任务改变为运行内核子程序。</p><p>当发生一个中断时，系统需要保存当前运行在CPU中进程的上下文，从而在其处理完后能恢复上下文，即先中断进程，之后在继续。</p><p>进程上下文用进程的PCB表示，它包括CPU寄存器的值，进程状态和内存管理信息等等。</p><h3 id="进程操作"><a href="#进程操作" class="headerlink" title="进程操作"></a>进程操作</h3><p>进程可以并发执行，他们可以动态创建和删除。</p><h4 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h4><p>进程在其执行的过程中，能通过创建进程系统调用创建多个新进程。</p><p>pid</p><p>进程创建新程序的时候，有两种执行可能：</p><ol><li>父进程与子进程并发执行</li><li>父进程等待，直到某个或者全部子进程执行完</li></ol><p>新进程的地址空间也有两种可能：</p><ol><li>子进程是父进程的复制品 （具有与父进程相同的程序和数据）</li><li>子进程装入新的程序</li></ol><p>在Unix中，每一个进程都用一个唯一的整数形式的进程标识符来标识。通过fork() 系统调用，可创建新进程。新进程通过复制原来进程的地址空间而成。这种机制允许父进程与子进程方便地进行通信。两个进程都继续执行位于系统调用fork()之后的指令。但是有一点不同，对于新进程，系统调用fork()的返回值为0，对与父进程返回值为子进程的进程标识符（非零）</p><p>通常，在系统调用fork()之后，一个进程会使用系统调用exec(),以用新程序来取代进程的内存空间。系统调用exec()将二进制文件装入内存，并开始执行。采用这种方法，两个进程能相互通信，并能按照各自的方法执行。父进程能创建更多的子进程，或者如果子进程运行是没什么可做，那么它采用系统调用wait()把自己移出就绪队列来等待子进程终止。</p><h4 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h4><p>当进程完成执行最后的语句并使用系统调用exit()请求操作系统删除自身时，进程终止</p><p>这时，进程返回状态值到父进程（通过系统调用wait())</p><p>有的系统，不允许子进程在父进程已终止的情况下存在。对于这类系统，如果一个进程终止，那么它所有子进程也将终止。这种现象，成为<strong>级联终止（cascading termination</strong>, 通常与操作系统进行。</p><p>Unix： 可以通过exit()来终止进程，父进程可以通过系统调用wait()以等待子进程的终止。系统调用wait()返回了终止子进程的进程标识符，以使父进程能够知道哪个子进程终止了。如果父进程终止，那么其所有子进程会以init为父进程。因此，子进程仍然有一个父进程来收集状态和执行统计。</p><h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p>需要进程间通信机制（interprocess communication， IPC） 来允许进程相互交换数据与信息。进程间通信有两种基本模式： </p><ol><li>共享内存</li></ol><p>建立起一块供协作进程共享的内存区域，进程通过向此共享区域读或者写入数据来交换信息。</p><ol><li>消息传递</li></ol><p>通过在写作进程间交换信息来实现通信。</p><p><img src="/images/IPCmodel.jpg" alt=""></p><p>在操作系统中，上述两种模式都很常用，而且许多系统的确同时使用了两种模式。</p><p>消息传递对于交换数量较少的数据很有用，因为不需要避免冲突。对于计算机间的通信，消息传递也碧共享内存更容易实现。</p><p>共享内存被消息传递快，消息传递系统通常通系统调用实现，因此需要更多的内核介入的时间消耗。</p><p>于此相反，在共享内存系统中，仅仅在建立共享内存区域时需要系统调用，一旦建立了共享内存，所有的访问都被处理成常规的内存访问，不需要来自内核的帮助。</p><h4 id="共享内存系统"><a href="#共享内存系统" class="headerlink" title="共享内存系统"></a>共享内存系统</h4><p>采用共享内存的进程间通信需要通信进程建立共享内存空间。通常，一块共享内存区域驻留在生成内存段进程的地址空间上。它们通过在共享区域读或者写来交换信息。数据的形式或位置取决于这些进程，而不是受控与操作系统。进程还负责保证它们不向同一区域同时写数据。</p><h4 id="消息传递系统"><a href="#消息传递系统" class="headerlink" title="消息传递系统"></a>消息传递系统</h4><p>消息传递提供一种机制以允许进程不必通过共享地址空间来实现通信和同步，这再分布式环境中特别有用。例如用于WWW的chat程序就是通过消息交换来实现通信的。</p><p>消息传递工具至少提供两种操作：<strong>发送</strong>和<strong>接受</strong></p><p>一些消息传递逻辑实现</p><ul><li>直接或者间接通信</li><li>同步或者异步同步</li><li>自动或者显式缓存</li></ul><ol><li><strong><em>命名</em></strong><br>需要通信的进程必须有一个方法以相互引用，他们可以直接或者间接通信</li></ol><p><strong>直接通信</strong>：</p><ul><li>在需要通信的每对进程之间自动建立线路。进程仅需要知道相互通信的标识符</li><li>一个线路只与两个进程相关</li><li>每对进程之间只有一条线路</li></ul><p>可以对称或者非对称寻址</p><p>缺点是限制了进程定义的模块化。改变进程的名称可能必须检查所有其他进程定义。所有旧名称的引用都必须找到，以便修改成新名称。</p><p><strong>间接通信</strong>： 通过邮箱或者端口来发送和接受消息。邮箱可以抽象成一个对象，进程可以向其中存放消息，也可以从中删除消息。每一个邮箱都有一个唯一的标识符。</p><ul><li>只有在两个进程共享一个邮箱时，才能建立通讯线路</li><li>一个线路可以与两个或者更多的进程相关联</li><li>两个通信进程之间可以有多个不同的线路，每个线路对应一个邮箱</li></ul><p>进程或者操作系统可以拥有邮箱。如果邮箱为进程所有（即邮箱是进程地址空间的一部分）那么需要区分拥有者（只能通过邮箱接受消息）和使用者（只能向邮箱发送消息）。</p><p>由于每个邮箱都有唯一的标识符，所以谁能接收到邮箱的消息是没什么疑问的。当拥有的邮箱的进程终止，那么邮箱将消失任何进程后来向该邮箱发送消息，都会得知邮箱不在存在。</p><p>由操作系统所拥有的邮箱是独立存在的，并不属于某个特定的进程。因此，操作系统必须提供机制以允许进程进行如下操作：</p><ul><li>创建新邮箱</li><li>通过邮箱发送和接收消息</li><li>删除邮箱</li></ul><ol><li><strong><em>同步</em></strong></li></ol><ul><li>阻塞send：发送进程阻塞，直到消息被接收进程或者邮箱接收</li><li>非阻塞send： 发送进程发送消息冰继续操作</li><li>阻塞receive： 接收者阻塞，直到有消息可用</li><li>非阻塞receive：接收者收到一个有效消息或者空消息</li></ul><ol><li><strong><em>缓冲</em></strong></li></ol><ul><li>零容量 ： 队列最大长度为0，线路中不能有任何消息处于等待。必须阻塞发送，直到接收者接收到消息</li><li>有限容量： 有限长度为n。如果在发送新消息时队列未满，那么该消息可以放在队列里，且发送者可继续执行不必等待。如果线路满，必须阻塞发送者，直到队列中空间可用为止。</li><li>无限容量： 长度无限，不管多少消息都可在其中等待，从不阻塞发送。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;进程 进程状态 PCB 进程调度 进程创建和删除 进程间通信&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Dairy-2018-01-02</title>
    <link href="http://www.yutong-han.net/2018/01/02/dairy-0102/"/>
    <id>http://www.yutong-han.net/2018/01/02/dairy-0102/</id>
    <published>2018-01-02T08:02:57.646Z</published>
    <updated>2018-01-03T18:31:55.762Z</updated>
    
    <content type="html"><![CDATA[<p>每日学习日记 2018-01-02<br><a id="more"></a><br>2018年啦！继续加油！元旦小小的浪了两天就看看了scala， 今天回来开始继续刷题！</p><h4 id="19-Remove-Nth-Node-From-End-of-List"><a href="#19-Remove-Nth-Node-From-End-of-List" class="headerlink" title="19.Remove Nth Node From End of List"></a><a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/description/" target="_blank" rel="noopener">19.Remove Nth Node From End of List</a></h4><ul><li>两个指针 fast and slow maintain n gap</li><li>同样注意要加一个dummy head</li></ul><h4 id="161-One-Edit-Distance"><a href="#161-One-Edit-Distance" class="headerlink" title="161. One Edit Distance"></a><a href="https://leetcode.com/problems/one-edit-distance/description/" target="_blank" rel="noopener">161. One Edit Distance</a></h4><ul><li>求两个字符串的编辑距离是否等于一</li><li>如果长度差大于1 肯定false</li><li>如果某一位置不一样<ul><li>Insert or Delete： 那么长的string从下一位开始的substring等于短的string从当前位置开始的substring</li><li>replace 从下一个开始的字串相等</li></ul></li><li>最后返回 |length1-length2|==1</li></ul><h4 id="72-Edit-Distance"><a href="#72-Edit-Distance" class="headerlink" title="72. Edit Distance"></a><a href="https://leetcode.com/problems/edit-distance/description/" target="_blank" rel="noopener">72. Edit Distance</a></h4><p>编辑距离<br>a) Insert a character<br>b) Delete a character<br>c) Replace a character</p><p>有一个很好的讲这个的slide <a href="https://web.stanford.edu/class/cs124/lec/med.pdf" target="_blank" rel="noopener">Edit Distance</a></p><ul><li><p>For two string</p><ul><li>X of length n</li><li>Y of length m</li></ul></li><li><p>Define D(i,j)</p><ul><li>the edit distance between X[1..i] and Y[1..j] </li><li>The!edit!distance!between!X!and!Y!is!thus!D(n,m)</li></ul></li><li><p>Bottom up DP to solve this problem</p></li></ul><p><img src="/images/editdistance.jpg" alt=""><br>(In Levenshtein distance substitution cost 2)</p><h4 id="114-Flatten-Binary-Tree-to-Linked-List"><a href="#114-Flatten-Binary-Tree-to-Linked-List" class="headerlink" title="114. Flatten Binary Tree to Linked List"></a><a href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/description/" target="_blank" rel="noopener">114. Flatten Binary Tree to Linked List</a></h4><p>后序遍历， 只写了递归的 没写迭代的，以后补上</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;每日学习日记 2018-01-02&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Spark with Scala-Introduction to Spark</title>
    <link href="http://www.yutong-han.net/2018/01/01/spark-3/"/>
    <id>http://www.yutong-han.net/2018/01/01/spark-3/</id>
    <published>2018-01-02T07:34:20.531Z</published>
    <updated>2018-01-02T08:27:36.753Z</updated>
    
    <content type="html"><![CDATA[<p>“A fast and general engine for large-scale data processing”<br><a id="more"></a></p><p><img src="/images/sparkcontext.png" alt=""></p><ul><li>Drive Program : develop</li><li>cluster manager (Spark,YARN)</li><li>Executor : automantically </li></ul><ul><li>“Run programs up to 100x faster than Hadoop MapReduce in memory, or 10x faster on disk”</li><li>DAG Engine (directed acyclic graph) optimizes workflows</li><li>Built around one main concept: the Resilient Distributed Dataset(RDD)</li></ul><h4 id="Components-of-Spark"><a href="#Components-of-Spark" class="headerlink" title="Components of Spark"></a>Components of Spark</h4><p><img src="/images/sparkcomponent.jpg" alt=""></p><ul><li>Spark core deals with the basics of dealing with RDD</li><li>Spark streaming: real time data streams</li><li>SQL : database</li><li>MLLib : Machine learning</li><li>Graphx : graph</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;“A fast and general engine for large-scale data processing”&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Spark with Scala 02 - Functions and Data Structures in Scala</title>
    <link href="http://www.yutong-han.net/2018/01/01/spark-2/"/>
    <id>http://www.yutong-han.net/2018/01/01/spark-2/</id>
    <published>2018-01-02T00:02:19.455Z</published>
    <updated>2018-01-02T07:32:47.656Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Functions-in-Scala"><a href="#Functions-in-Scala" class="headerlink" title="Functions in Scala"></a>Functions in Scala</h4><p>Format is <code>def &lt;function name&gt;(parameter name:type...):return type = {expression}</code><br>Don’t forget the = befor the expression</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def squareIt(x: Int) : Int = &#123;</span><br><span class="line">    x*x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def cubeIt(x: Int) : Int =&#123;x*x*x&#125;</span><br></pre></td></tr></table></figure><p><strong>Functions can take other functions as parameters</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def transformInt(x: int, f: Int =&gt; Int) :Int =&#123;</span><br><span class="line">    f(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val result = transformInt (2, cubeIt)</span><br></pre></td></tr></table></figure><p>Don’t even need to have a separate function declared.<br>“Lambda functions”,”anonymous functions”,”function literals”<br>can declare functions inline without even giving them a name</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">transformInt(3, x=&gt; x*x*x) //&gt; res0: 27</span><br><span class="line"></span><br><span class="line">transfromInt(10,x=&gt; x/2) //&gt; res1: 5</span><br><span class="line"></span><br><span class="line">transformInt(2, x=&gt;&#123;val y =x *2;y*y&#125;) //&gt; res2: 16</span><br></pre></td></tr></table></figure><h4 id="Data-structures-in-Scala"><a href="#Data-structures-in-Scala" class="headerlink" title="Data structures in Scala"></a>Data structures in Scala</h4><h5 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h5><ul><li>tuple</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val tuple = &#123;&quot;A&quot;,&quot;B&quot;,&quot;C&quot;&#125; //&gt; tuple :(String,String,String)=(A,B,C)</span><br><span class="line">println (tuple) // &gt;(A,B,C)</span><br></pre></td></tr></table></figure><p>ONE-Based Index</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">println(tuple._1) //&gt;A</span><br><span class="line">println(tuple._2) //&gt;B</span><br><span class="line">println(tuple._3) //&gt;C</span><br></pre></td></tr></table></figure><ul><li>key/value</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val map = &quot;A&quot;-&gt;&quot;a&quot; //&gt; map: (String,String) = (A,a)</span><br><span class="line">println(map._2) //&gt; a</span><br></pre></td></tr></table></figure><ul><li>Can mix differnent types in a tuple</li></ul><h5 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h5><p>Like a tuple but it’s an actual Collection objetxt that has more functionality<br>It cannoy hold items of different types<br>It’s a singly-linked list under the hood</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val lists = List(&quot;A1&quot;,&quot;B2&quot;,&quot;C3&quot;,&quot;D4&quot;) //&gt; lists : List[String] = List(A1,B2,C3,D4)</span><br></pre></td></tr></table></figure><ul><li>Access individual members using () with Zero-Based index!</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(lists(1)) //&gt; B2</span><br></pre></td></tr></table></figure><ul><li>head and tail give you the first item and the remaining ones</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">println (lists.head) //&gt; A1</span><br><span class="line">println (lists.tail) //&gt; List(B2,C3,D4)</span><br></pre></td></tr></table></figure><ul><li>Iterating though a list</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(l &lt;- lists)&#123;println(l)&#125; //&gt;A1</span><br><span class="line">                            //|B2</span><br><span class="line">                            //|C3</span><br><span class="line">                            //|D4</span><br></pre></td></tr></table></figure><ul><li>map() can be used to apply any function to every item in a collection </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val backwardList = lists.map((l:String)=&gt;&#123;l.reverse&#125;)</span><br></pre></td></tr></table></figure><ul><li>reduce() can be used to combine together all the items in a collection using some function </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val numberList = List(1,2,3,4,5)</span><br><span class="line">val sum = numberList.reduce((x:Int,y:Int)=&gt; x+y) //&gt; sum : Int =15</span><br></pre></td></tr></table></figure><ul><li>filter() can remove stuff you don’t want. </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val noFive = numberList.filter ((s:Int)=&gt;x!5) //&gt; noFive : List[Int] = List(1,2,3,4)</span><br><span class="line">val noThree = numberList.filter (_!=3) //&gt; noThree : Lust[Int] = List(1,2,4,5)</span><br></pre></td></tr></table></figure><ul><li><p>concatenating lists</p><ul><li>use ++ to combine two list together</li></ul></li><li><p>Reverse: <code>lists.reverse</code></p></li><li>Sort: <code>list.sort</code></li><li>Distinct value : <code>list.distinct</code></li><li>Max value : <code>list.max</code></li><li>Sum : <code>list.sum</code></li><li>contains: <code>list.contains(value)</code></li></ul><h5 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val map = Map(&quot;A&quot;-&gt;&quot;1&quot;, &quot;B&quot;-&gt;&quot;2&quot;, &quot;C&quot;-&gt;&quot;3&quot;)</span><br><span class="line"></span><br><span class="line">println(map(&quot;A&quot;)) //&gt; 1</span><br></pre></td></tr></table></figure><ul><li>deal with missing value</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">println(map.contains(&quot;D&quot;)) //false</span><br><span class="line"></span><br><span class="line">val Dmap = util.Try (map(&quot;D&quot;)) getOrElse = &quot;Unknow&quot; //Dmap : String = Unknow</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Functions-in-Scala&quot;&gt;&lt;a href=&quot;#Functions-in-Scala&quot; class=&quot;headerlink&quot; title=&quot;Functions in Scala&quot;&gt;&lt;/a&gt;Functions in Scala&lt;/h4&gt;&lt;p&gt;Format
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Spark with Scala 01 - Scala basics</title>
    <link href="http://www.yutong-han.net/2017/12/31/spark-1/"/>
    <id>http://www.yutong-han.net/2017/12/31/spark-1/</id>
    <published>2017-12-31T23:10:51.388Z</published>
    <updated>2018-01-02T00:28:19.753Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Scala"><a href="#Scala" class="headerlink" title="Scala"></a>Scala</h3><h4 id="What-is-scala"><a href="#What-is-scala" class="headerlink" title="What is scala"></a>What is scala</h4><ul><li>It’s what spark is built with<ul><li>New features are often scala first</li><li>Spark can also be programed with Python and Java</li></ul></li><li>Runs on the top of the JVM<ul><li>can access Java classes</li></ul></li><li>Functional programming<ul><li>In the functional programming, we use a lot of functions</li><li>encourage immutable constant </li></ul></li></ul><h4 id="Scala-Basic"><a href="#Scala-Basic" class="headerlink" title="Scala Basic"></a>Scala Basic</h4><ol><li>immutable constant : <strong>val</strong><ul><li>eg. <code>val hello: String =&quot;Hola!&quot;</code></li><li>name this immutable constant <code>hello</code> type is string and set value as “Hola!”</li></ul></li><li>mutable constant : <strong>var</strong></li><li>println<ul><li>format numerical: start with <code>f</code></li><li>substituting <code>s</code></li><li>regluar expression: triple quote syntax follow by a dot R</li><li><code>val pattern(answerString) = theAnswer</code></li></ul></li><li>Boolean<ul><li><code>val isGreater = 1&gt;2</code></li><li><code>val isLesser = 1&lt;2</code></li><li><code>val impossible = isGreater &amp; is Lesser</code></li><li><code>val isEqual : Boolean = a==b</code></li></ul></li><li><p>if/else</p><ul><li><code>if(...){..} else {..}</code></li></ul></li><li><p>matching (like switch)</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val number =3</span><br><span class="line">number match&#123;</span><br><span class="line">    case 1 =&gt; ...</span><br><span class="line">    case 2 =&gt; ...</span><br><span class="line">    case _ =&gt; (else)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Flow-Control"><a href="#Flow-Control" class="headerlink" title="Flow Control"></a>Flow Control</h4><ol><li>for loop</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(x &lt;- 1 to 4)&#123;</span><br><span class="line">    val s = x*x</span><br><span class="line">    println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>while loop</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var x =10</span><br><span class="line">while (x&gt;=0)&#123;</span><br><span class="line">    println&#123;x&#125;</span><br><span class="line">    x-=1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">x=0</span><br><span class="line">do&#123;println&#123;x&#125;;x+=1&#125;while(x&lt;=10)</span><br></pre></td></tr></table></figure><ol><li>Expressions<ul><li>“Returns” the final value in a block automatically</li></ul></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;val x = 10;x+20&#125; //&gt; res0: Int =30</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Scala&quot;&gt;&lt;a href=&quot;#Scala&quot; class=&quot;headerlink&quot; title=&quot;Scala&quot;&gt;&lt;/a&gt;Scala&lt;/h3&gt;&lt;h4 id=&quot;What-is-scala&quot;&gt;&lt;a href=&quot;#What-is-scala&quot; class=&quot;header
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Dairy-2017-12-29</title>
    <link href="http://www.yutong-han.net/2017/12/29/dairy-1229/"/>
    <id>http://www.yutong-han.net/2017/12/29/dairy-1229/</id>
    <published>2017-12-29T23:27:31.873Z</published>
    <updated>2018-01-01T23:36:10.810Z</updated>
    
    <content type="html"><![CDATA[<p>每日学习日记 2017-12-29<br><a id="more"></a></p><ul><li><p>分割类DP</p><ul><li><p>Maximum Subarray</p><ul><li>一个模版</li><li>Math.max(cur+nums[i],nums[i])</li><li>Math.max(cur,max)</li></ul></li><li><p>Maximum Product Subarray</p><ul><li>注意乘法和加法不同在于最大值可能通过最小值乘负数得来，所以要维护最大值和最小值，同时正负的时候要进行你不同操作</li></ul></li></ul></li></ul><ul><li><p>Best Time to Buy and Sell Stock 系列</p><ul><li>I<ul><li>一次买卖： max=Math.max(max,nums[i]-min); min = Math.min(min, nums[i]);</li></ul></li><li>II<ul><li>无数次买卖，只要后面一个比前一个高就买卖</li></ul></li><li>III （需要重做）<ul><li>最多两次买卖</li></ul></li><li>IV  （需要重做）<ul><li>最多k次</li></ul></li></ul></li><li><p>Longest Common Substring </p><ul><li>最长公共子串（要求连续） 扫描一遍即可</li></ul></li><li>Longest Common Subsequence<ul><li>最长公共子序列 <ul><li>方法一DP dp[A.length()][B.length()] dp[i][j]={dp[i-1][j-1]+1 if A[i]=B[j]}{Max(dp[i-1][j],dp[i][j-1])}</li></ul></li></ul></li><li>Longest Continuous Increasing Subsequence<ul><li>套路其实和Maximum Subarray一样但是更简单</li></ul></li><li>Longest Increasing Subsequence<ul><li>方法一dp </li></ul></li><li>Number of LIS<ul><li>保留两个dp数组 </li><li>len[] 和LIS中的dp一样 保存到当前位置的最长增序列的长度</li><li>count[] 保存到当前位置的最长增序列的数量， 如果len[i]==len[j]+1的时候说明有重复的 count[i]+=count[j]</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;每日学习日记 2017-12-29&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>操作系统复习笔记 02</title>
    <link href="http://www.yutong-han.net/2017/12/27/OS-2/"/>
    <id>http://www.yutong-han.net/2017/12/27/OS-2/</id>
    <published>2017-12-28T07:26:04.799Z</published>
    <updated>2017-12-31T01:17:33.770Z</updated>
    
    <content type="html"><![CDATA[<p>操作系统复习笔记 操作系统的任务和计算机系统组织<br><a id="more"></a><br>操作系统为执行程序提供运行环境。它为运行程序和使用这些程序的用户提供一定的服务。<br>下图展示了操作系统提供的各类服务以及他们之间的关系。<br><img src="/images/osservices.png" alt=""></p><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>向操作系统传递参数又三种方法。最简单的是通过<strong>寄存器来传递参数</strong>。有时，参数数量会比寄存器多，这时，这些参数通常<strong>存在内存的块和表</strong>中，并将块的地址通过寄存器来传递。参数也可以通过程序<strong>放在或者压入堆栈中，并通过操作系统弹出</strong></p><p>系统调用的种类</p><ol><li>Process Control<ul><li>end, abort</li><li>load,execute</li><li>create process terminate process</li><li>get process attributes set porcess attribute</li><li>wait for time</li><li>wait event signal event</li><li>allocate and free memory</li></ul></li><li>File management<ul><li>create file, delete file</li><li>open, close</li><li>read write reposition</li><li>get file attribute set file attributes</li></ul></li><li>Device management<ul><li>request device, release device</li><li>read write repostion </li><li>get device attributes set device attributes</li><li>logically attach or detach devices</li></ul></li><li>Information maintenance <ul><li>get time or date, set time or date</li><li>get system data, set system data</li><li>get process, file or device attributes</li><li>set process, file or device attributes</li></ul></li><li>Communications <ul><li>create delete communication connection</li><li>send receive messages </li><li>transfer status information</li><li>attach or detach remote devices</li></ul></li></ol><h3 id="OS-structure"><a href="#OS-structure" class="headerlink" title="OS structure"></a>OS structure</h3><h4 id="Simple-Structure"><a href="#Simple-Structure" class="headerlink" title="Simple Structure"></a>Simple Structure</h4><ul><li>Difficult to implement and maintain.   </li><li>Perfomance advantage: there is very little overhead in the system</li></ul><h4 id="Layered-Approach-分层"><a href="#Layered-Approach-分层" class="headerlink" title="Layered Approach 分层"></a>Layered Approach 分层</h4><ul><li>OS is broken into a number of layers</li><li>The bottom layer(layer 0) is the hardware</li><li>The highest(Layer N)is the user interface</li><li>A typical layer consists of data strutures and a set of routines that can be invoked bu higher-level layers.<ul><li>In turn this layer can invoke operation on lower-level layers.</li></ul></li><li>Advantage:<ul><li>Simplicity of contruction and debugging</li></ul></li><li>Difficulty:<ul><li>Appropriately defining the various layers</li><li>tend to be less efficient than other types</li></ul></li></ul><h4 id="MicroKernel-微内核"><a href="#MicroKernel-微内核" class="headerlink" title="MicroKernel 微内核"></a>MicroKernel 微内核</h4><ul><li>Removing all nonessential components from the kernel and implementing them as sysyem and user-level programs.</li><li>Result is a smaller kernel.</li><li>Main function :provide communication between the cient program and the various services that are also running in user space.</li><li>Communication is provided through messahe passing.</li><li>Benefits:<ul><li>It makes ectending the operating system easier.</li><li>easier to port the operating system to new architectures</li><li>more reliable</li></ul></li><li>Difficulty:<ul><li>suffer due to increased system-function overhead</li></ul></li></ul><h4 id="Modules-模块"><a href="#Modules-模块" class="headerlink" title="Modules 模块"></a>Modules 模块</h4><ul><li>Object-oriented</li><li>each core component is separate</li><li>clearly defined interfaces</li><li>each is loadanble as needed within the kernel </li><li>similar to layers but with more flexible</li></ul><h3 id="Virtual-Machine"><a href="#Virtual-Machine" class="headerlink" title="Virtual Machine"></a>Virtual Machine</h3><p>Allow one hardware to run different systems</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;操作系统复习笔记 操作系统的任务和计算机系统组织&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Dairy-2017-12-27</title>
    <link href="http://www.yutong-han.net/2017/12/27/dairy-1227/"/>
    <id>http://www.yutong-han.net/2017/12/27/dairy-1227/</id>
    <published>2017-12-27T09:35:03.527Z</published>
    <updated>2017-12-30T19:58:37.807Z</updated>
    
    <content type="html"><![CDATA[<p>每日学习日记 2017-12-27<br><a id="more"></a><br>今日任务：<br>OS看完第二章</p><p>继续做DP经典题</p><h3 id="博弈DP-MiniMax：-能得到的是maximize-the-minimum-gain"><a href="#博弈DP-MiniMax：-能得到的是maximize-the-minimum-gain" class="headerlink" title="博弈DP MiniMax： 能得到的是maximize the minimum gain"></a><strong>博弈DP MiniMax</strong>： 能得到的是maximize the minimum gain</h3><p>Coins in a Line 有取巧的return n % 3 != 0 ;办法<br>Coins in a Line II： 带有具体值的Conins in a Line  有两种方法：top-down and bottom-up<br>375 Guess Number Higher or Lower II <em>需要重做</em><br>Flip Game 1 2</p><pre><code>- 1是2的一个引子- </code></pre><p>Nim game 三个选择的Coins 取巧办法%4</p><p>Palindrome Partitioning II<br>Burst Balloons<br>Scramble String</p><p>Longest Common Subsequence<br>One Edit Distance<br>Edit Distance<br>Minimum insertions to form a palindrome<br>WildCard Matching<br>Regular Expression Mathcing<br>Word Break<br>Word Break II<br>Interleaving String<br>Bomb Enemy</p><p>背包系列</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;每日学习日记 2017-12-27&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Dairy-2017-12-26</title>
    <link href="http://www.yutong-han.net/2017/12/26/dairy-1226/"/>
    <id>http://www.yutong-han.net/2017/12/26/dairy-1226/</id>
    <published>2017-12-26T08:27:40.184Z</published>
    <updated>2017-12-27T09:35:52.614Z</updated>
    
    <content type="html"><![CDATA[<p>每日学习日记 2017-12-26<br><a id="more"></a></p><ul><li>漆栅栏，漆墙，再漆房<ul><li>Paint Fence</li><li>Paint House</li><li>Paint House II</li></ul></li><li>滚动数组<ul><li>Minimum Path Sum</li><li>Maximal Square</li></ul></li><li>记忆化搜索<ul><li>Longest Increasing Path in a Matrix </li></ul></li><li>博弈型DP<ul><li>375 Guess Number Higher or Lower II 需要重做</li><li>Guess Number Higher or Lower （并不是dp，但是居然二分搜索TLE了！！需要三分搜索。注意一下。）</li></ul></li></ul><p>操作系统复习情况：<br>当年没有学计网的时候看的晕头转向的东西，突然想明白了一些了。<br>看完OS就去看计网啊，集群分布式都要考虑计算机网络才是。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;每日学习日记 2017-12-26&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Dairy-2017-12-25</title>
    <link href="http://www.yutong-han.net/2017/12/25/dairy-1225/"/>
    <id>http://www.yutong-han.net/2017/12/25/dairy-1225/</id>
    <published>2017-12-25T08:43:58.828Z</published>
    <updated>2017-12-26T08:29:02.206Z</updated>
    
    <content type="html"><![CDATA[<p>每日学习日记 2017-12-25<br><a id="more"></a><br>动态规划</p><ol><li>House Robber <ul><li>1</li><li>2</li><li>3</li></ul></li><li>漆栅栏，漆墙，再漆房<ul><li>Paint Fence</li><li>Paint House</li><li>(FB) Paint House II</li></ul></li><li>动态规划，矩阵路径，滚动数组<ul><li>Unique Paths II</li><li>Minimum Path Sum</li><li>Maximal Square</li><li>Maximal Rectangle</li></ul></li><li>动态规划，记忆化搜索<ul><li>Longest Increasing Continuous Subsequence</li><li>Longest Increasing Path in a Matrix </li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;每日学习日记 2017-12-25&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>操作系统复习笔记 01</title>
    <link href="http://www.yutong-han.net/2017/12/24/OS-1/"/>
    <id>http://www.yutong-han.net/2017/12/24/OS-1/</id>
    <published>2017-12-24T18:18:09.840Z</published>
    <updated>2017-12-28T07:27:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>操作系统复习笔记 操作系统的任务和计算机系统组织<br><a id="more"></a></p><h2 id="操作系统做了那些工作"><a href="#操作系统做了那些工作" class="headerlink" title="操作系统做了那些工作"></a>操作系统做了那些工作</h2><p>在整个的计算机系统中，操作系统究竟扮演着什么角色，首先要从计算机系统大概就分为那些组成开始说起<br>计算机系统大概分为 <strong>hardware</strong>, <strong>operating system</strong>, <strong>application programs</strong>以及<strong>user</strong></p><p>从系统的角度上看，操作系统是 <strong><em>resource allocator</em></strong> 。计算机系统中有着大量的resource例如CPU 时间，memory space, file-storage space I/O device.操作系统的作用就是当系统发生冲突<strong>conflict</strong>的时候，操作系统要公平有效的对资源进行分配。<br>另一种看法是操作系统是<strong>control program</strong>， 操作系统需要管理各种I/O设备。</p><h2 id="操作系统定义"><a href="#操作系统定义" class="headerlink" title="操作系统定义"></a>操作系统定义</h2><p>一个比较常见的定义是将操作系统看作是一个一直运行的被称为<strong>kernel</strong>的程序。（除了kernel之外计算机还有两种程序，一种是system programs一种是application prgrams.)</p><h2 id="计算机系统组织"><a href="#计算机系统组织" class="headerlink" title="计算机系统组织"></a>计算机系统组织</h2><p>在探讨操作系统操作之前，需要先了解一下计算机系统的基本结构</p><h4 id="计算机系统操作"><a href="#计算机系统操作" class="headerlink" title="计算机系统操作"></a>计算机系统操作</h4><p>现代计算机又一个或多个CPU和若干设备控制器通过common bus连接而成， common bus提供了对共享内存的访问。 每个设备控制器控制一种特定类型的设备。CPU和设备控制器可以并行工作，同时竞争内存周期。为了确保对共享内存的有序访问，需要内存控制器来协调对内存的访问。</p><p>当打开电源或者重启时，计算机开始运行。这个时间他需要运行一个初始化的程序，bootstrap， bootstrap是一个简单的程序，他一般存储在computer hardware read-only memory<strong>ROM</strong>或者electrically erasable programmable read-only memory（<strong>EEPROM</strong>）。bootstrap需要知道如何加载OS，如何启动执行程序，所以bootstrap程序需要在在kernel中并且放入内存。</p><p>当kernel加载成功并且运行时，他会开启一些服务。其中一些服务不在内核中，他在boot time的时候被加载到内核中。这些进程被称做是<strong>system process</strong>或者<strong>system daemons（守护进程）</strong>。 在Unix系统中 第一个进程是init， 它会开启许多daemons，完成这些过程后系统加载完成，系统等待事务event出现。</p><p>事件的发生通常通过通过硬件或者软件的中断<strong>interrupt</strong>来表示。硬件可随时通过系统总线向CPU发出信号，以触发中断。软件通过执行特别操作如系统调用（system call）也能触发中断</p><p>CPU中断的时候，CPU将暂停它现在在做的事情转到固定的位置去继续执行。该固定位置一般是中断服务程序开始的地方。中断服务开始执行，执行结束后CPU重新执行被中断的计算。</p><p>处理转移的的简单方法是调用一个通用子程序来检查中断信息。接着，该子程序会调用相应的中断处理程序，由于只有少量的预先定义的中断，所以可以使用中断处理子程序的指针表。这样通过指针表可间接调用中断处理子程序，而不需要通过其他中间子程序。 通常，指针表位于低地址内存。这些位置包含各种设备的中断处理子程序地址。这种地址的数组或中断向量（<strong>interrupt vector</strong>） 课通过唯一设备号来索引， 以提供设备的中断处理子程序的地址。</p><p>中断体系结构也保存被中断指令的地址。现代结构返回系统堆栈中的地址。如果中断处理程序需要修改处理器状态，如修改寄存器的值，它必须明确地保存当前状态并在返回前恢复该状态。在处理中断之后，保存的返回地址会装入程序计数器，被中断的计算可以重新开始。</p><h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><p>计算机程序必须在内存（或者随机访问内存random access memory， RAM） 中以便于运行</p><p>内存是处理可以直接访问的唯一大容量存储区域。他通常是用被称为动态随机访问内存 DRAM 的半导体技术实现的，通过一系列的load store指令来交互。</p><p>理想状态下程序和数据都存储在内存中，但是由于<strong>内存太小</strong>，<strong>内存是易失性存储设备，掉电会失去所有内容</strong>所以是不可能的。<br>因此绝大多数计算机都提供secondary storage 作为内存的扩充。</p><h4 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h4><p>对于大块的数据移动，比如磁盘I/O，会有超载问题。 DMA（direct memory access） 就是为了解决这个问题而设计的。这位这种IO设备设置好缓冲，指针和计数器之后，设备控制器能在本地缓冲和内存之间传送一整块数据，而无需CPU的干预。每块只产生一个中断，来告知设备驱动程序操作已经完成，为不像低速设备那样每个字节产生一个中断。当设备控制器在执行这些操作的时候，CPU可以去完成其他工作。</p><h4 id="集群系统"><a href="#集群系统" class="headerlink" title="集群系统"></a>集群系统</h4><p>集群系统雨多处理器系统不同，它是有两个多多个独立的系统耦合起来的</p><p>一个较为常用的定义是集群计算机共享存储并通过局域网链接，或者更快的内部链接。</p><p>集群通常用来提供高可用性服务</p><p>集群可以是对称的也可以是不对称的。</p><p>非对称集群中，一台机器处于热备份模式，而另一台运行应用程序。热备份主机只监视活动服务器。如果该服务器失效，那么热备份主机会成为先行服务器。</p><p>对于对称集群，两个或多个主机都运行应用程序，他们互相监视。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;操作系统复习笔记 操作系统的任务和计算机系统组织&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Dairy-2017-12-24</title>
    <link href="http://www.yutong-han.net/2017/12/24/dairy-1224/"/>
    <id>http://www.yutong-han.net/2017/12/24/dairy-1224/</id>
    <published>2017-12-24T08:07:20.502Z</published>
    <updated>2017-12-24T08:09:55.393Z</updated>
    
    <content type="html"><![CDATA[<p>和学长聊了一下感觉收获颇丰<br>从今天开始要开始复习基础课啦！<br>先从操作系统开始吧<br>白天用心刷题，晚上回来复习基础课<br>明天任务：<br>Strobogrammatic 数生成</p><pre><code>- Strobogrammatic Number 1 2 3</code></pre><p>DP题目：</p><p>复习任务：<br>写完一篇读书笔记</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;和学长聊了一下感觉收获颇丰&lt;br&gt;从今天开始要开始复习基础课啦！&lt;br&gt;先从操作系统开始吧&lt;br&gt;白天用心刷题，晚上回来复习基础课&lt;br&gt;明天任务：&lt;br&gt;Strobogrammatic 数生成&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- Strobogrammatic Number
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Dairy-2017-12-22</title>
    <link href="http://www.yutong-han.net/2017/12/22/dairy-1222/"/>
    <id>http://www.yutong-han.net/2017/12/22/dairy-1222/</id>
    <published>2017-12-23T07:33:20.378Z</published>
    <updated>2017-12-24T08:07:10.743Z</updated>
    
    <content type="html"><![CDATA[<p>这周周末任务全面的复习一下回溯法：</p><ol><li>排列组合系列：<ul><li>Subsets 1 2 </li><li>Combination，Combination Sum 1 2 3 4 </li><li>Permutation 1 2 </li></ul></li><li>N 皇后 1 2 </li><li>数独</li><li>Word Ladder 1 2 </li><li>Number of Ways<ul><li>Android Unlock Patterns</li><li>Decode Ways</li></ul></li><li>DFS flood filling<ul><li>Word Search </li><li>Number of Islands</li><li>Surrounded Regions</li></ul></li><li>Strobogrammatic 数生成<ul><li>Strobogrammatic Number 1 2 3</li></ul></li><li>String 构造式<ul><li>Generalized Abbreviation</li><li>Remove Invalid Parentheses</li><li>Expression Add Operators</li></ul></li><li>Word Pattern I &amp; II</li><li>枚举法<ul><li>Generate Parentheses</li><li>Restore IP Addresses</li><li>Palindrome Partitioning</li><li>Letter Combinations of a Phone Number </li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这周周末任务全面的复习一下回溯法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;排列组合系列：&lt;ul&gt;
&lt;li&gt;Subsets 1 2 &lt;/li&gt;
&lt;li&gt;Combination，Combination Sum 1 2 3 4 &lt;/li&gt;
&lt;li&gt;Permutation 1 2 &lt;/li&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Dairy-2017-12-21</title>
    <link href="http://www.yutong-han.net/2017/12/21/dairy-1221/"/>
    <id>http://www.yutong-han.net/2017/12/21/dairy-1221/</id>
    <published>2017-12-21T08:29:58.340Z</published>
    <updated>2017-12-22T07:28:05.585Z</updated>
    
    <content type="html"><![CDATA[<p>每日学习日记 2017-12-20<br><a id="more"></a><br>回溯的经典题看了个七七八八了<br>今天做点应用</p><ol><li>216    Combination Sum III (Done)</li><li>377 Combination Sum IV (Done)</li><li>17 Letter Combinations of a Phone Number(Done)</li><li>131 Palindrome Partitioning(Done)</li><li>51 N-Queens（hard）（Done)</li><li>52     N-Queens II （hard）(Done)</li></ol><p>复习 </p><ol><li>subset 12 (Done)</li><li>permutation12 (Done)</li><li>combination (Done)</li><li>241 Different Ways to Add Parentheses(Done)</li></ol><p>选做：</p><ol><li>10 Regular Expression Matching（hard）</li><li>282 Expression Add Operators</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;每日学习日记 2017-12-20&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Dairy-2017-12-20</title>
    <link href="http://www.yutong-han.net/2017/12/20/dairy-1220/"/>
    <id>http://www.yutong-han.net/2017/12/20/dairy-1220/</id>
    <published>2017-12-20T20:26:39.551Z</published>
    <updated>2017-12-21T08:29:49.728Z</updated>
    
    <content type="html"><![CDATA[<p>每日学习日记 2017-12-20<br><a id="more"></a><br>今天收到了Hulu的约面试通知，约了一个月之后。希望能约成功吧。<br>加油加油希望接下来努力！顺利！！<br>今日任务：<br>跟学长确定一下recommendation的项目<br>继续做回溯的题！今天要把回溯吃透！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;每日学习日记 2017-12-20&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Dairy-2017-12-19</title>
    <link href="http://www.yutong-han.net/2017/12/19/dairy-1219/"/>
    <id>http://www.yutong-han.net/2017/12/19/dairy-1219/</id>
    <published>2017-12-19T08:04:37.961Z</published>
    <updated>2017-12-20T20:26:20.751Z</updated>
    
    <content type="html"><![CDATA[<p>每日学习日记 2017-12-19<br><a id="more"></a><br>今日任务：<br>leetcode 107-110最少<br>foo 到level 3  完成<br>主要做回溯部分</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;每日学习日记 2017-12-19&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Dairy-2017-12-18</title>
    <link href="http://www.yutong-han.net/2017/12/18/dairy-12-18/"/>
    <id>http://www.yutong-han.net/2017/12/18/dairy-12-18/</id>
    <published>2017-12-19T07:38:02.654Z</published>
    <updated>2017-12-19T07:44:22.019Z</updated>
    
    <content type="html"><![CDATA[<p>每日学习日记 2017-12-18<br><a id="more"></a></p><p>今天复习了快速排序，快速选择算法<br>真的感觉一遇到递归相关问题就很容易炸毛。。</p><p>晚上做了一下gg的foobar，感觉自己还是很弱啊。。。<br>明天继续做回溯算法相关，如果有时间复习一下二叉树</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;每日学习日记 2017-12-18&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Dairy-2017-1217</title>
    <link href="http://www.yutong-han.net/2017/12/17/dairy-1217/"/>
    <id>http://www.yutong-han.net/2017/12/17/dairy-1217/</id>
    <published>2017-12-17T23:30:18.820Z</published>
    <updated>2017-12-18T06:28:58.208Z</updated>
    
    <content type="html"><![CDATA[<p>学习了一下分治算法，感觉自己递归相关还是软肋啊</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;学习了一下分治算法，感觉自己递归相关还是软肋啊&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Dairy-2017-12-16</title>
    <link href="http://www.yutong-han.net/2017/12/16/dairy-1216/"/>
    <id>http://www.yutong-han.net/2017/12/16/dairy-1216/</id>
    <published>2017-12-17T00:35:16.091Z</published>
    <updated>2017-12-17T23:30:28.155Z</updated>
    
    <content type="html"><![CDATA[<p>Spark 配置和简单的小程序 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Spark 配置和简单的小程序 &lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
</feed>
